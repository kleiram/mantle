{"name":"Mantle","tagline":"Easy model mapping","body":"# Mantle\r\n\r\nMantle makes it easy to write a simple model layer for your PHP applications.\r\n\r\n## Installation\r\n\r\nVia Composer:\r\n\r\n```json\r\n{\r\n    \"require\": {\r\n        \"mantle/mantle\": \"~1.0\"\r\n    }\r\n}\r\n```\r\n\r\n## Usage\r\n\r\nWhat's wrong with the way models are usually written in PHP?\r\n\r\nLet's use the GitHub API as an example. How would one usually represent a\r\n[GitHub issue](https://developer.github.com/v3/issues/#get-a-single-issue) in PHP?\r\n\r\n```php\r\n<?php\r\nclass Issue\r\n{\r\n    const STATE_CLOSED  = 0;\r\n    const STATE_OPEN    = 1;\r\n\r\n    /** @var string */\r\n    public $url;\r\n\r\n    /** @var string */\r\n    public $htmlUrl;\r\n\r\n    /** @var integer */\r\n    public $number;\r\n\r\n    /** @var integer */\r\n    public $state;\r\n\r\n    /** @var string */\r\n    public $reporterLogin;\r\n\r\n    /** @var User */\r\n    public $assignee;\r\n\r\n    /** @var DateTime */\r\n    public $updatedAt;\r\n\r\n    /** @var string */\r\n    public $title;\r\n\r\n    /** @var string */\r\n    public $body;\r\n}\r\n```\r\n\r\nSeems perfectly fine! Now, what happens when we want to map a JSON response from\r\nthe GitHub API to this model? We end up with a _lot_ of mapping code:\r\n\r\n```php\r\n<?php\r\n$json = ...; // Get response from GitHub API\r\n\r\n$assignee   = new User();\r\n$issue      = new Issue();\r\n\r\n$issue->url             = $json->url;\r\n$issue->htmlUrl         = $json->html_url;\r\n$issue->number          = $json->number;\r\n$issue->updatedAt       = new \\DateTime($json->updated_at);\r\n\r\n$issue->title           = $json->title;\r\n$issue->body            = $json->body;\r\n\r\n$issue->reporterLogin   = $json->user->login;\r\n$issue->assignee        = $assignee;\r\n\r\n$issue->state           = $json->state == 'open' ? Issue::STATE_OPEN : Issue::STATE_CLOSED;\r\n\r\n// And even more code to parse the assignee property!\r\n```\r\n\r\nWhoaw, that is a lot of boilerplate code for something that is so common! And\r\neven now there are still issues:\r\n\r\n - If the `url` or `html_url` fields are missing in the response, an error will\r\n   be thrown;\r\n - There is no way to update a `Issue` with new data from the server;\r\n\r\n ## Insert Mantle\r\n\r\nThis is where Mantle comes in! Using Mantle, the above code can be changed into:\r\n\r\n```php\r\n$json = ...; // Get response from GitHub API\r\n\r\n$mantle = new Mantle\\Mantle();\r\n$issue  = $mantle->transform($json, 'Issue');\r\n```\r\n\r\nIt's that easy! Mantle will try and build the object by looking at properties in\r\nthe class that you specifiy (it should be the `FQCN`) and it will even try to\r\nconvert `camelCase` names to `snake_case`!\r\n\r\n### Property mapping\r\n\r\nThe only thing it will not do (and that's a good thing, since it won't know what\r\nto do) is convert nested properties (such as the `reporterLogin` property).\r\n\r\nLuckily, you won't have to do that by hand after the `Issue` object is created!\r\nMantle will try and look for a `getPropertyMapping` method in your `Model`\r\nclass, and if it exists, use that mapping over the one it creates by itself.\r\nThat means that our `Issue` model has to be extended a little bit:\r\n\r\n```php\r\n<?php\r\nclass Issue\r\n{\r\n    // Properties\r\n\r\n    public function getPropertyMapping()\r\n    {\r\n        return array(\r\n            'reporterLogin' => 'user.login'\r\n        );\r\n    }\r\n}\r\n```\r\n\r\nMantle expects that an array is returned from the `getPropertyMapping` method\r\nin which the keys of the array are the properties of the model and the\r\nvalues are JSON key-paths. If you don't implement this method, Mantle will\r\nstill work, it just won't handle nested values.\r\n\r\nIf there are some properties that exist both in the model and the JSON object\r\nthat you (for some reason) don't want mapped, you can set a `null` value as\r\nthe value for the property:\r\n\r\n```php\r\n<?php\r\nreturn array(\r\n    'unmapped-property' => null\r\n);\r\n```\r\n\r\n### Transformers\r\n\r\nIf we look at the `Issue` model again, there are some things that might raise\r\nquestions: the `updatedAt`, `assignee` and `state` properties.\r\n\r\nYou can let Mantle handle this too by specifying _transformers_. A transformer\r\nis a method that transforms an input value to another output value.\r\n\r\nTransforming these properties is really easy. All you have to do is create some\r\nextra methods in your model. For the `updatedAt` and `state` properties, they\r\nmight look something like this:\r\n\r\n```php\r\npublic function updatedAtTransformer($updatedAt)\r\n{\r\n    return new \\DateTime($updatedAt);\r\n}\r\n\r\npublic function stateTransformer($state)\r\n{\r\n    return $state == 'open' ? static::STATE_OPEN : static::STATE_CLOSED;\r\n}\r\n```\r\n\r\nMantle expects transformers to have the name `[property]Transformer`.\r\n\r\nThis leaves us with only one thing left: the `assignee` property. As usual,\r\nyou'll only have to define one extra (really simple) method to transform\r\nthis property:\r\n\r\n```php\r\npublic function assigneeClass()\r\n{\r\n    return 'User';\r\n}\r\n```\r\n\r\n(It's assumed that a `User` class exists).\r\n\r\nMantle expects that you return the `FQCN` of the class for the class that you\r\nwant the JSON object to be transformed into. It can even handle arrays for you!\r\nLet's say that you have a JSON response like so (not related to the GitHub API):\r\n\r\n```json\r\n{\r\n    \"username\": \"bob\",\r\n    \"tickets\": [\r\n        {\r\n            \"title\": \"Foo\",\r\n            \"body\": \"Lorem ipsum dolor sit amet\"\r\n        },\r\n        {\r\n            \"title\": \"Bar\",\r\n            \"body\": \"Lorem ipsum dolor sit amet\"\r\n        },\r\n        {\r\n            \"title\": \"Baz\",\r\n            \"body\": \"Lorem ipsum dolor sit amet\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nYou can then (in a fictive `User` model) implement the `ticketsClass` method\r\nthat returns (for example) `Vendor\\Project\\Model\\Ticket`. Mantle will transform\r\nthe `tickets` field in the JSON response into an array of `Ticket` models for\r\nyou!\r\n\r\n### Existing objects\r\n\r\nIt happens (sometimes) that you want to update an existing object with new data\r\nfrom the server. Well, Mantle handles that too! Instead of passing class name\r\nas the second argument for Mantle you can pass an existing object:\r\n\r\n```php\r\n<?php\r\n$data = ...; // Fetch user data from somewhere\r\n\r\n$mantle = new Mantle();\r\n$user   = $mantle->transform($data, 'User');\r\n\r\n// A lot of stuff happens, maybe some time passes\r\n\r\n$data = ...; // Fetch fresh user data from somewhere\r\n$user = $mantle->transform($data, $user);\r\n```\r\n\r\nThe only requirement is that the `$data` passed is actually an `stdClass` object\r\nand not an `array` (an array wouldn't make sense in this case since you're only\r\ntransforming a single object).\r\n\r\n### Data source\r\n\r\nThere's no requirement for what kind of data source you have to use. You can\r\nfetch data from a remote server or a local file or even create a `stdClass`\r\nobject in the application itself and map it using Mantle!\r\n\r\n### Callbacks\r\n\r\nAn extra functionality in Mantle is the possibility to specify a callback that's\r\ncalled when the transformation of an object is complete. This way, it's possible\r\nto perform extra operations on each object in an array or a specific object\r\nwithout having to do extra work after the transformation. Basically, it changes\r\nthe following piece of code:\r\n\r\n```php\r\n<?php\r\n$data = ...; // A list of users fetched from somewhere\r\n$group = new Vendor\\Project\\Group();\r\n\r\n$mantle = new Mantle();\r\n$users = $mantle->transform($data, 'Vendor\\Project\\User');\r\n\r\nforeach ($users as $user) {\r\n    $user->setGroup($group);\r\n}\r\n```\r\n\r\nTo this:\r\n\r\n```php\r\n$data = ...; // A list of users fetched from somewhere\r\n$group = new Vendor\\Project\\Group();\r\n\r\n$mantle = new Mantle();\r\n$users = $mantle->transform($data, 'Vendor\\Project\\User', function ($user) use ($group) {\r\n    $user->setGroup($group);\r\n});\r\n```\r\n\r\nIt's, of course, totally up to you whether you want to use a closure, the name\r\nof a function or even a class method!\r\n\r\n## Testing\r\n\r\nMantle is fully unit tested. The tests can be run with PHPUnit:\r\n\r\n```shell\r\n$ phpunit\r\n```\r\n\r\n## Contributing\r\n\r\nPlease see [CONTRIBUTING](https://github.com/kleiram/mantle/blob/master/CONTRIBUTING.md)\r\nfor details.\r\n\r\n## Credits\r\n\r\n - [Ramon Kleiss](https://github.com/kleiram)\r\n - [All Contributors](https://github.com/kleiram/mantle/contributors)\r\n\r\n## License\r\n\r\nThe MIT License (MIT). Please see [License File](https://github.com/kleiram/mantle/blob/master/LICENSE)\r\nfor more information.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}